{"dependencies":[{"name":"invariant"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _invariant = require(\"invariant\");\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Grid = function () {\n  function Grid(width, height, cells) {\n    _classCallCheck(this, Grid);\n\n    (0, _invariant2.default)(width > 0, \"width must be positive\");\n    (0, _invariant2.default)(height > 0, \"height must be positive\");\n\n    this.width = width;\n    this.height = height;\n\n    if (cells != null) {\n      (0, _invariant2.default)(cells.length === width * height, \"initial cell length must equal WxH\");\n\n      this.cells = cells;\n    } else {\n      this.cells = new Array(width * height).fill(null);\n    }\n  }\n\n  _createClass(Grid, [{\n    key: \"coordsToIndex\",\n    value: function coordsToIndex(x, y) {\n      (0, _invariant2.default)(x >= 0, \"x must be greater than 0\");\n      (0, _invariant2.default)(x < this.width, \"x must be less than width\");\n      (0, _invariant2.default)(y >= 0, \"y must be greater than 0\");\n      (0, _invariant2.default)(y < this.height, \"y must be less than height\");\n\n      return x + y * this.width;\n    }\n  }, {\n    key: \"wrapX\",\n    value: function wrapX(x) {\n      if (x < 0) return this.width + x % this.width;\n      return x % this.width;\n    }\n  }, {\n    key: \"indexToXCoord\",\n    value: function indexToXCoord(index) {\n      (0, _invariant2.default)(index >= 0, \"index must be greater than 0\");\n      (0, _invariant2.default)(index < this.length, \"index must be less than length\");\n\n      return index % this.width;\n    }\n  }, {\n    key: \"wrapY\",\n    value: function wrapY(y) {\n      if (y < 0) return this.height + y % this.height;\n      return y % this.height;\n    }\n  }, {\n    key: \"indexToYCoord\",\n    value: function indexToYCoord(index) {\n      (0, _invariant2.default)(index >= 0, \"index must be greater than 0\");\n      (0, _invariant2.default)(index < this.length, \"index must be less than length\");\n\n      return Math.floor(index / this.width);\n    }\n  }, {\n    key: \"forEach\",\n    value: function forEach(callback) {\n      var _this = this;\n\n      this.cells.forEach(function (cell, index) {\n        var x = _this.indexToXCoord(index);\n        var y = _this.indexToYCoord(index);\n        callback(cell, x, y, _this);\n      });\n    }\n  }, {\n    key: \"map\",\n    value: function map(callback) {\n      var _this2 = this;\n\n      var newCells = new Array(this.length);\n\n      this.forEach(function (cell, x, y) {\n        var index = _this2.coordsToIndex(x, y);\n        newCells[index] = callback(cell, x, y, _this2);\n      });\n\n      return new Grid(this.width, this.height, newCells);\n    }\n  }, {\n    key: \"fill\",\n    value: function fill(value) {\n      return this.map(function () {\n        return value;\n      });\n    }\n  }, {\n    key: \"valueAtIndex\",\n    value: function valueAtIndex(index) {\n      (0, _invariant2.default)(index >= 0, \"index must be positive\");\n      (0, _invariant2.default)(index < this.length, \"index must be less than length\");\n\n      return this.cells[index];\n    }\n  }, {\n    key: \"valueAtCoords\",\n    value: function valueAtCoords(x, y) {\n      var index = this.coordsToIndex(x, y);\n      return this.valueAtIndex(index);\n    }\n  }, {\n    key: \"neighboursRoundCoord\",\n    value: function neighboursRoundCoord(x, y) {\n      var _this3 = this;\n\n      var deltas = [[1, 0], [1, 1], [0, 1], [-1, 1], [-1, 0], [-1, -1], [0, -1], [1, -1]];\n\n      return deltas.map(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            dx = _ref2[0],\n            dy = _ref2[1];\n\n        return _this3.valueAtCoords(_this3.wrapX(x + dx), _this3.wrapY(y + dy));\n      });\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      (0, _invariant2.default)(this.cells.length === this.width * this.height, \"length must be consistent\");\n\n      return this.cells.length;\n    }\n  }]);\n\n  return Grid;\n}();\n\nexports.default = Grid;"},"hash":"ec96d49538f4f7c11f30665f7285d59e"}